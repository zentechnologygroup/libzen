# include <iostream>

# include <ah-stl-utils.H>

# include <units.H>
# include <units-list.H>

# include <json.hpp>

using json = nlohmann::json;

static void init_unit_converters();

// the following data is declared in units.H
UnitItemTable * PhysicalQuantity::tbl = nullptr;

UnitItemTable * Unit::tbl = nullptr;

DynSetTree<const Unit *> * Unit::unit_tbl = nullptr;

static size_t fst_unit_pair_hash
(const pair<pair<const Unit*, const Unit*>, Unit_Convert_Fct_Ptr> & p)
{
  return dft_hash_fct(p.first);
}

static size_t snd_unit_pair_hash
(const pair<pair<const Unit*, const Unit*>, Unit_Convert_Fct_Ptr> & p)
{
  return snd_hash_fct(p.first);
}

UnitMap * __unit_map = nullptr;
CompoundUnitTbl * __compound_unit_tbl = nullptr;

const PhysicalQuantity PhysicalQuantity::null_physical_quantity;

const Unit Unit::null_unit;

const double Unit::Invalid_Value = numeric_limits<double>::max();

const VtlQuantity VtlQuantity::null_quantity;

/* The goal of this function is to assure that the tables required by
   the units system are adequately initialized. 

   The technique consists in instantiating the required tables as
   static variables of this constructor. In this way we assure that
   tables are instantiated exactly once time. These static variables
   use the default constructor. Then, on each table the real
   constructor is called through the placement new operator
*/
UnitsInstancer::UnitsInstancer()
{
  static size_t count = 0;
  if (count++ > 0)
    ZENTHROW(InvariantError, "UnitsInstancer::UnitsInstancer() called twice");
  static UnitItemTable physicalquantity_tbl;
  static UnitItemTable unit_tbl;
  static DynSetTree<const Unit *> unit_unit_tbl;

  PhysicalQuantity::tbl = &physicalquantity_tbl;
  Unit::tbl = &unit_tbl;
  Unit::unit_tbl = &unit_unit_tbl;

  static UnitMap __unit_map(3000, fst_unit_pair_hash, snd_unit_pair_hash);
  ::__unit_map = &__unit_map;

  static CompoundUnitTbl __compound_unit_tbl;
  ::__compound_unit_tbl = &__compound_unit_tbl;

  new ((void*) &PhysicalQuantity::null_physical_quantity)
    PhysicalQuantity("NullPhysicalQuantity", "NullPQ",
		     "Null" "Null Physical Quantity");

  new ((void*) &Unit::null_unit) Unit("NullUnit", "Null Unit", "Null unit", "Null",
				      PhysicalQuantity::null_physical_quantity,
				      numeric_limits<double>::min(),
				      numeric_limits<double>::max());

  new ((void*) &VtlQuantity::null_quantity)
    VtlQuantity(Unit::null_unit, numeric_limits<double>::max());

  init_unit_converters(); // this routine is generated by extract-cv
			  // script and concatenated to this file
}

bool conversion_exist(const char * src_symbol, const char * tgt_symbol)
{
  return exist_conversion(src_symbol, tgt_symbol);
}

double unit_convert(const char * src_symbol, const char * tgt_symbol,
		    double val)
{
  return unit_convert_symbol_to_symbol(src_symbol, val, tgt_symbol);
}

static json to_json(const Unit * unit_ptr)
{
  json j;
  j["name"] = unit_ptr->name;
  j["description"] = unit_ptr->description;
  j["symbol"] = unit_ptr->symbol;
  j["latex_symbol"] = unit_ptr->latex_symbol;
  j["minimum_value"] = unit_ptr->min_val;
  j["maximum_value"] = unit_ptr->max_val;
  j["epsilon"] = unit_ptr->get_epsilon();
  return j;
}

static json to_json(const PhysicalQuantity * const pq)
{
  json j;
  j["name"] = pq->name;
  j["description"] = pq->description;
  j["symbol"] = pq->symbol;
  j["latex_symbol"] = pq->latex_symbol;
  j["units"] =
    to_vector(pq->units().maps<json>([] (auto p) { return to_json(p); }));
  
  return j;
}

string units_json()
{
  json j;
  j["Zen_physical_quantities"] =
    to_vector(PhysicalQuantity::quantities().maps<json>([] (auto p)
    { return to_json(p); }));
  return j.dump(2);
}

const UnitsInstancer & units_instance = UnitsInstancer::init();

// The following global singleton variables are generated by extract-cv script
